# -*- coding: utf-8 -*-
"""Python_OOPs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GPhyCY6Sa2asLcHZoOqQKz2PjB7cQceU

## Python OOPS Theory Questions and Answers

Here are the answers to the theoretical questions from the "python oops.pdf" file, supplemented with information from web searches.

### Python OOPs Questions

1.  **What is Object-Oriented Programming (OOP)?**
    Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects." These objects can contain both data (attributes or properties) and the actions or behaviors that can be performed on that data (methods or procedures). The core idea is to design programs by making them out of interacting objects, simplifying software development and maintenance.

2.  **What is a class in OOP?**
    In OOP, a class is a blueprint or a template for creating objects. It defines the shared characteristics (attributes/variables) and behaviors (methods/functions) that objects created from that class will possess. Classes promote modularity, reusability, and code organization.

3.  **What is an object in OOP?**
    An object is an instance of a class. It is a self-contained component that consists of methods and properties to make a particular type of data useful. Objects are often used to model real-world entities.

4.  **What is the difference between abstraction and encapsulation?**
    * **Abstraction** is the process of hiding unwanted information and showing only the essential attributes and relevant details to the user. It focuses on "what" needs to be done.
    * **Encapsulation** is the process of wrapping data and the code that operates on that data into a single unit (like a class) and controlling access to it. It focuses on "how" it should be done and protects information from outside access.

5.  **What are dunder methods in Python?**
    Dunder methods, also known as "magic methods," are special methods in Python whose names start and end with double underscores (e.g., `__init__`, `__str__`, `__add__`). They allow instances of a class to interact with Python's built-in functions and operators, forming the backbone of Python's data model.

6.  **Explain the concept of inheritance in OOP.**
    Inheritance is a mechanism in OOP that allows a new class (subclass or derived class) to inherit properties and behaviors (attributes and methods) from an existing class (superclass or base class). This promotes code reusability and establishes a "is-a" relationship between classes. For example, a `Dog` class can inherit from an `Animal` class, meaning a Dog "is a" Animal.

7.  **What is polymorphism in OOP?**
    Polymorphism means "many forms." In OOP, it refers to the ability of different classes to respond to the same method call in their own specific ways. This means a single interface can be used for different underlying data types, leading to more flexible and extensible code.

8.  **How is encapsulation achieved in Python?**
    Encapsulation in Python is primarily achieved by convention. While Python doesn't have strict access modifiers like `private` or `public` found in some other languages, developers use a single underscore `_` prefix for attributes and methods to indicate that they are intended for internal use (protected) and a double underscore `__` prefix for name mangling, which makes attributes and methods harder to access directly from outside the class (private). The idea is to control access to data through public methods (getters and setters).

9.  **What is a constructor in Python?**
    In Python, the `__init__` method acts as a constructor. It is a special method that is automatically called when a new object (instance) of a class is created. Its purpose is to initialize the object's attributes and set up its initial state.

10. **What are class and static methods in Python?**
    * **Class Methods:** These methods are bound to the class itself, not to an instance of the class. They can access and modify class-level attributes and are defined using the `@classmethod` decorator. The first parameter is conventionally `cls`, referring to the class object.
    * **Static Methods:** These methods are also bound to the class but do not take `self` or `cls` as their first argument. They are defined using the `@staticmethod` decorator and are essentially regular functions that happen to be defined within a class. They don't interact with instance-specific data or class-specific data, but rather perform utility functions related to the class.

11. **What is method overloading in Python?**
    Method overloading refers to defining multiple methods with the same name but different parameters within the same class. Python does not support traditional method overloading in the same way as some other languages (like Java or C++) where you can have multiple methods with the same name and different signatures. In Python, if you define multiple methods with the same name, the last one defined will override the previous ones. However, you can achieve similar functionality using default arguments, variable-length arguments (`*args`, `**kwargs`), or by checking argument types within a single method.

12. **What is method overriding in OOP?**
    Method overriding is a feature in OOP where a subclass provides a specific implementation for a method that is already defined in its superclass. This allows a subclass to change or extend the behavior of an inherited method, demonstrating polymorphism.

13. **What is a property decorator in Python?**
    The `@property` decorator in Python provides a way to define methods that can be accessed like attributes. It allows you to create "getters," "setters," and "deleters" for attributes, providing controlled access to them without directly exposing the internal data. This helps in maintaining encapsulation and makes the code more Pythonic.

14. **Why is polymorphism important in OOP?**
    Polymorphism is crucial in OOP because it allows for writing more flexible, extensible, and maintainable code. It enables a single interface to be used for different data types, meaning you can write generic code that works with objects of various classes, as long as they adhere to a common interface. This reduces code duplication and improves code organization.

15. **What is an abstract class in Python?**
    An abstract class is a class that cannot be instantiated directly. It is designed to be a blueprint for other classes, often containing one or more abstract methods. An abstract method is a method declared in the abstract class but has no implementation, forcing its subclasses to provide the implementation. In Python, you use the `abc` module (Abstract Base Classes) and the `@abstractmethod` decorator to define abstract classes and methods.

16. **What are the advantages of OOP?**
    The advantages of OOP include:
    * **Modularity:** Breaking down complex problems into smaller, manageable objects.
    * **Reusability:** Reusing existing code through inheritance and composition.
    * **Maintainability:** Easier to debug and maintain code due to independent objects and encapsulation.
    * **Flexibility and Extensibility:** Easier to add new features or modify existing ones without affecting other parts of the system.
    * **Data Security:** Encapsulation helps protect data from unintended external access.

17. **What is the difference between a class variable and an instance variable?**
    * **Class Variables:** These variables are shared by all instances of a class. They are defined directly within the class but outside of any methods. Changes to a class variable affect all instances of that class.
    * **Instance Variables:** These variables are unique to each instance (object) of a class. They are defined within the constructor (`__init__` method) using `self.variable_name`. Each instance has its own copy of instance variables.

18. **What is multiple inheritance in Python?**
    Multiple inheritance is a feature in OOP where a class can inherit attributes and methods from multiple parent classes. This allows a subclass to combine behaviors from several different sources. While powerful, it can sometimes lead to complexities like the "diamond problem" if not managed carefully. Python supports multiple inheritance.

19. **Explain the purpose of `__str__` and `__repr__` methods in Python.**
    * `__str__` method: This method is used to provide a human-readable string representation of an object. It's called by `str()` and `print()`. Its primary purpose is for end-users to understand the object.
    * `__repr__` method: This method is used to provide an "official" or unambiguous string representation of an object, primarily for developers. It's called by `repr()` and is the fallback if `__str__` is not defined. The goal is to provide a string that, if passed to `eval()`, would ideally recreate the object.

20. **What is the significance of the `super()` function in Python?**
    The `super()` function in Python is used to call methods and access attributes of a parent or sibling class in an inheritance hierarchy. Its primary use is within a subclass's method to call the corresponding method of its superclass, especially in constructors (`__init__`) to ensure proper initialization of inherited attributes.

21. **What is the significance of the `__del__` method in Python?**
    The `__del__` method (also known as the destructor) is a special method in Python that is called when an object is about to be destroyed (i.e., its reference count drops to zero and it's garbage-collected). It's primarily used for cleanup operations, such as closing file handlers or releasing external resources. However, its use is generally discouraged for typical resource management, as Python's garbage collector handles memory automatically, and the exact timing of `__del__` calls can be unpredictable.

22. **What is the difference between `@staticmethod` and `@classmethod` in Python?**
    * `@staticmethod`: This decorator is used to define a static method. Static methods do not receive any implicit first argument (like `self` for instance methods or `cls` for class methods). They are essentially functions defined within a class that don't operate on the instance or the class itself, but logically belong to the class.
    * `@classmethod`: This decorator is used to define a class method. Class methods receive the class itself as their first argument (conventionally named `cls`). They can access and modify class-level attributes and can be used as alternative constructors or for operations that involve the class as a whole rather than a specific instance.

23. **How does polymorphism work in Python with inheritance?**
    Polymorphism with inheritance in Python works through method overriding. When a subclass overrides a method from its superclass, objects of the subclass will execute their own version of that method when called, while objects of the superclass will execute the superclass's version. This allows different objects to respond to the same method call in different ways, depending on their actual type.

24. **What is method chaining in Python OOP?**
    Method chaining (or fluent interface) is a programming technique where multiple method calls are strung together on a single object. This is achieved by having each method return the object itself (usually `self`), allowing another method to be called immediately on the returned object. This can lead to more concise and readable code, especially when performing a sequence of operations on an object.

25. **What is the purpose of the `__call__` method in Python?**
    The `__call__` method is a special method in Python that makes an instance of a class callable like a function. If this method is defined in a class, you can call an object of that class by using parentheses `()` after its name, just like you would call a function. This allows objects to behave as functions and can be useful for creating function-like objects or decorators.
"""

#  1. Create a parent class Animal with a method speak() that prints a generic message. Create a child class Dog
# that overrides the speak() method to print "Bark!".

class Animal:
    def speak(self):
        print("This animal makes a sound.")

class Dog(Animal):
    def speak(self):
        print("Bark!")

# Demonstrate
animal = Animal()
animal.speak()

dog = Dog()
dog.speak()

#2. Write a program to create an abstract class Shape with a method area(). Derive classes Circle and Rectangle from it and implement the area() method in both.

from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius**2

class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

# Demonstrate
circle = Circle(5)
print(f"Area of Circle: {circle.area()}")

rectangle = Rectangle(4, 6)
print(f"Area of Rectangle: {rectangle.area()}")

#3. Implement a multi-level inheritance scenario where a class Vehicle has an attribute type. Derive a class Car and further derive a class ElectricCar that adds a battery attribute

class Vehicle:
    def __init__(self, vehicle_type):
        self.type = vehicle_type

    def get_vehicle_info(self):
        return f"Vehicle Type: {self.type}"

class Car(Vehicle):
    def __init__(self, vehicle_type, brand):
        super().__init__(vehicle_type)
        self.brand = brand

    def get_car_info(self):
        return f"{self.get_vehicle_info()}, Brand: {self.brand}"

class ElectricCar(Car):
    def __init__(self, vehicle_type, brand, battery_capacity):
        super().__init__(vehicle_type, brand)
        self.battery_capacity = battery_capacity

    def get_electric_car_info(self):
        return f"{self.get_car_info()}, Battery Capacity: {self.battery_capacity} kWh"

# Demonstrate
electric_car = ElectricCar("Sedan", "Tesla", 75)
print(electric_car.get_electric_car_info())

#4. Demonstrate polymorphism by creating a base class Bird with a method fly(). Create two derived classes Sparrow and Penguin that override the fly() method

class Bird:
    def fly(self):
        print("This bird flies.")

class Sparrow(Bird):
    def fly(self):
        print("Sparrows fly high in the sky.")

class Penguin(Bird):
    def fly(self):
        print("Penguins cannot fly, but they can swim!")

# Demonstrate
bird = Bird()
bird.fly()

sparrow = Sparrow()
sparrow.fly()

penguin = Penguin()
penguin.fly()

#5. Write a program to demonstrate encapsulation by creating a class BankAccount with private attributes balance and methods to deposit, withdraw, and check balance.

class BankAccount:
    def __init__(self, initial_balance=0):
        self.__balance = initial_balance # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: ${amount}. New balance: ${self.__balance}")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if amount > 0 and self.__balance >= amount:
            self.__balance -= amount
            print(f"Withdrew: ${amount}. New balance: ${self.__balance}")
        else:
            print("Invalid withdrawal amount or insufficient balance.")

    def get_balance(self):
        return self.__balance

# Demonstrate
account = BankAccount(100)
account.deposit(50)
account.withdraw(30)
print(f"Current balance: ${account.get_balance()}")

# Trying to directly access the private attribute will lead to an AttributeError
# print(account.__balance) # This would raise an error

#6. Demonstrate runtime polymorphism using a method play() in a base class Instrument. Derive classes Guitar and Piano that implement their own version of play()

class Instrument:
    def play(self):
        print("The instrument is playing a sound.")

class Guitar(Instrument):
    def play(self):
        print("The guitar is strumming a melody.")

class Piano(Instrument):
    def play(self):
        print("The piano is playing a beautiful tune.")

# Demonstrate
def make_instrument_play(instrument):
    instrument.play()

guitar = Guitar()
piano = Piano()

make_instrument_play(guitar)
make_instrument_play(piano)

#7. Create a class MathOperations with a class method add_numbers() to add two numbers and a static method subtract_numbers() to subtract two numbers

class MathOperations:
    @classmethod
    def add_numbers(cls, a, b):
        return a + b

    @staticmethod
    def subtract_numbers(a, b):
        return a - b

# Demonstrate
print(f"Addition using class method: {MathOperations.add_numbers(10, 5)}")
print(f"Subtraction using static method: {MathOperations.subtract_numbers(10, 5)}")

#8. Implement a class Person with a class method to count the total number of persons created

class Person:
    number_of_persons = 0 # Class variable

    def __init__(self, name):
        self.name = name
        Person.number_of_persons += 1

    @classmethod
    def get_total_persons(cls):
        return cls.number_of_persons

# Demonstrate
person1 = Person("Alice")
person2 = Person("Bob")
person3 = Person("Charlie")

print(f"Total number of persons created: {Person.get_total_persons()}")

#9. Write a class Fraction with attributes numerator and denominator. Override the str method to display the fraction as "numerator/denominator".

class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

# Demonstrate
fraction = Fraction(3, 4)
print(f"The fraction is: {fraction}")

#10. Demonstrate operator overloading by creating a class Vector and overriding the add method to add two vectors.

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        else:
            raise TypeError("Can only add Vector objects to Vector objects.")

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# Demonstrate
v1 = Vector(2, 3)
v2 = Vector(1, 4)
v3 = v1 + v2
print(f"Vector 1: {v1}")
print(f"Vector 2: {v2}")
print(f"Sum of vectors: {v3}")

#11. Create a class Person with attributes name and age. Add a method greet() that prints "Hello, my name is {name} and I am {age} years old."

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

# Demonstrate
person = Person("Deepak", 30)
person.greet()

#12. Implement a class Student with attributes name and grades. Create a method average_grade() to compute the average of the grades.

class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades # grades should be a list of numbers

    def average_grade(self):
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)

# Demonstrate
student1 = Student("Priya", [85, 90, 78, 92])
print(f"{student1.name}'s average grade: {student1.average_grade():.2f}")

student2 = Student("Rahul", [])
print(f"{student2.name}'s average grade: {student2.average_grade():.2f}")

#13. Create a class Rectangle with methods set_dimensions() to set the dimensions and area() to calculate the area.

class Rectangle:
    def __init__(self):
        self.length = 0
        self.width = 0

    def set_dimensions(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

# Demonstrate
rect = Rectangle()
rect.set_dimensions(7, 8)
print(f"Area of the rectangle: {rect.area()}")

#14. Create a class Employee with a method calculate_salary() that computes the salary based on hours worked and hourly rate. Create a derived class Manager that adds a bonus to the salary

class Employee:
    def __init__(self, hours_worked, hourly_rate):
        self.hours_worked = hours_worked
        self.hourly_rate = hourly_rate

    def calculate_salary(self):
        return self.hours_worked * self.hourly_rate

class Manager(Employee):
    def __init__(self, hours_worked, hourly_rate, bonus):
        super().__init__(hours_worked, hourly_rate)
        self.bonus = bonus

    def calculate_salary(self):
        base_salary = super().calculate_salary()
        return base_salary + self.bonus

# Demonstrate
employee = Employee(160, 25)
print(f"Employee salary: ${employee.calculate_salary():.2f}")

manager = Manager(160, 30, 500)
print(f"Manager salary: ${manager.calculate_salary():.2f}")

#15. Create a class Product with attributes name, price, and quantity. Implement a method total_price() that calculates the total price of the product.

class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def total_price(self):
        return self.price * self.quantity

# Demonstrate
product = Product("Laptop", 1200.50, 2)
print(f"Product: {product.name}, Total Price: ${product.total_price():.2f}")

#16. Create a class Animal with an abstract method sound(). Create two derived classes Cow and Sheep that implement the sound() method

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Cow(Animal):
    def sound(self):
        return "Moo!"

class Sheep(Animal):
    def sound(self):
        return "Baa!"

# Demonstrate
cow = Cow()
print(f"Cow says: {cow.sound()}")

sheep = Sheep()
print(f"Sheep says: {sheep.sound()}")

#17. Create a class Book with attributes title, author, and year_published. Add a method get_book_info() that returns a formatted string with the book's details.

class Book:
    def __init__(self, title, author, year_published):
        self.title = title
        self.author = author
        self.year_published = year_published

    def get_book_info(self):
        return f"Title: {self.title}, Author: {self.author}, Year Published: {self.year_published}"

# Demonstrate
book = Book("The Great Gatsby", "F. Scott Fitzgerald", 1925)
print(book.get_book_info())

#18. Create a class House with attributes address and price. Create a derived class Mansion that adds an attribute number_of_rooms

class House:
    def __init__(self, address, price):
        self.address = address
        self.price = price

    def get_house_info(self):
        return f"Address: {self.address}, Price: ${self.price:,.2f}"

class Mansion(House):
    def __init__(self, address, price, number_of_rooms):
        super().__init__(address, price)
        self.number_of_rooms = number_of_rooms

    def get_mansion_info(self):
        return f"{self.get_house_info()}, Number of Rooms: {self.number_of_rooms}"

# Demonstrate
house = House("123 Main St", 300000)
print(house.get_house_info())

mansion = Mansion("456 Grand Ave", 2500000, 15)
print(mansion.get_mansion_info())